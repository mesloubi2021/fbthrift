// Autogenerated by Thrift for thrift/test/go/if/dummy.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package dummy


import (
    "context"
    "fmt"
    "reflect"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
    metadata "github.com/facebook/fbthrift/thrift/lib/thrift/metadata"
)

// (needed to ensure safety because of naive import list construction)
var _ = context.Background
var _ = fmt.Printf
var _ = reflect.Ptr
var _ = thrift.ZERO
var _ = metadata.GoUnusedProtection__

type Dummy interface {
    Echo(ctx context.Context, value string) (string, error)
    OnewayRPC(ctx context.Context, value string) (error)
}

type DummyChannelClientInterface interface {
    thrift.ClientInterface
    Dummy
}

type DummyClientInterface interface {
    thrift.ClientInterface
    Echo(value string) (string, error)
    OnewayRPC(value string) (error)
}

type DummyContextClientInterface interface {
    DummyClientInterface
    EchoContext(ctx context.Context, value string) (string, error)
    OnewayRPCContext(ctx context.Context, value string) (error)
}

type DummyChannelClient struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ DummyChannelClientInterface = (*DummyChannelClient)(nil)

func NewDummyChannelClient(channel thrift.RequestChannel) *DummyChannelClient {
    return &DummyChannelClient{
        ch: channel,
    }
}

func (c *DummyChannelClient) Close() error {
    return c.ch.Close()
}

type DummyClient struct {
    chClient *DummyChannelClient
}
// Compile time interface enforcer
var _ DummyClientInterface = (*DummyClient)(nil)
var _ DummyContextClientInterface = (*DummyClient)(nil)

func NewDummyClient(prot thrift.Protocol) *DummyClient {
    return &DummyClient{
        chClient: NewDummyChannelClient(
            thrift.NewSerialChannel(prot),
        ),
    }
}

func (c *DummyClient) Close() error {
    return c.chClient.Close()
}

func (c *DummyChannelClient) Echo(ctx context.Context, value string) (string, error) {
    in := &reqDummyEcho{
        Value: value,
    }
    out := newRespDummyEcho()
    err := c.ch.Call(ctx, "Echo", in, out)
    if err != nil {
        return "", err
    }
    return out.GetSuccess(), nil
}

func (c *DummyClient) Echo(value string) (string, error) {
    return c.chClient.Echo(context.Background(), value)
}

func (c *DummyClient) EchoContext(ctx context.Context, value string) (string, error) {
    return c.chClient.Echo(ctx, value)
}

func (c *DummyChannelClient) OnewayRPC(ctx context.Context, value string) (error) {
    in := &reqDummyOnewayRPC{
        Value: value,
    }
    return c.ch.Oneway(ctx, "OnewayRPC", in)
}

func (c *DummyClient) OnewayRPC(value string) (error) {
    return c.chClient.OnewayRPC(context.Background(), value)
}

func (c *DummyClient) OnewayRPCContext(ctx context.Context, value string) (error) {
    return c.chClient.OnewayRPC(ctx, value)
}


type DummyProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler            Dummy
}

func NewDummyProcessor(handler Dummy) *DummyProcessor {
    p := &DummyProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("Echo", &procFuncDummyEcho{handler: handler})
    p.AddToProcessorFunctionMap("OnewayRPC", &procFuncDummyOnewayRPC{handler: handler})
    p.AddToFunctionServiceMap("Echo", "Dummy")
    p.AddToFunctionServiceMap("OnewayRPC", "Dummy")

    return p
}

func (p *DummyProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *DummyProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *DummyProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *DummyProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *DummyProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *DummyProcessor) PackageName() string {
    return "dummy"
}

func (p *DummyProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("dummy.Dummy")
}


type procFuncDummyEcho struct {
    handler Dummy
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncDummyEcho)(nil)

func (p *procFuncDummyEcho) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqDummyEcho()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncDummyEcho) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("Echo", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncDummyEcho) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqDummyEcho)
    result := newRespDummyEcho()
    retval, err := p.handler.Echo(ctx, args.Value)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing Echo: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncDummyOnewayRPC struct {
    handler Dummy
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncDummyOnewayRPC)(nil)

func (p *procFuncDummyOnewayRPC) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqDummyOnewayRPC()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncDummyOnewayRPC) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("OnewayRPC", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncDummyOnewayRPC) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqDummyOnewayRPC)
    err := p.handler.OnewayRPC(ctx, args.Value)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing OnewayRPC: " + err.Error(), err)
        return x, x
    }

    return nil, nil
}


