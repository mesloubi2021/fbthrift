// Autogenerated by Thrift for thrift/compiler/test/fixtures/go-service/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module


import (
    "context"
    "fmt"
    "reflect"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
    metadata "github.com/facebook/fbthrift/thrift/lib/thrift/metadata"
)

// (needed to ensure safety because of naive import list construction)
var _ = context.Background
var _ = fmt.Printf
var _ = reflect.Ptr
var _ = thrift.ZERO
var _ = metadata.GoUnusedProtection__

type GetEntity interface {
    GetEntity(ctx context.Context, r *GetEntityRequest) (*GetEntityResponse, error)
    GetBool(ctx context.Context) (bool, error)
    GetByte(ctx context.Context) (int8, error)
    GetI16(ctx context.Context) (int16, error)
    GetI32(ctx context.Context) (int32, error)
    GetI64(ctx context.Context) (int64, error)
    GetDouble(ctx context.Context) (float64, error)
    GetString(ctx context.Context) (string, error)
    GetBinary(ctx context.Context) ([]byte, error)
    GetMap(ctx context.Context) (map[string]string, error)
    GetSet(ctx context.Context) ([]string, error)
    GetList(ctx context.Context) ([]string, error)
    GetLegacyStuff(ctx context.Context, numPos int64, numNeg1 int64, numNeg2 int64) (int32, error)
    GetCtxCollision(ctx1 context.Context, ctx int64) (int32, error)
    GetCtx1Collision(ctx2 context.Context, ctx int64, ctx1 int64) (int32, error)
    GetContextCollision(ctx context.Context, context_ int64) (int32, error)
    GetOutCollision(ctx context.Context, out int64) (int32, error)
    GetOut1Collision(ctx context.Context, out int64, out1 int64) (int32, error)
    GetInCollision(ctx context.Context, in int64) (int32, error)
    GetIn1Collision(ctx context.Context, in int64, in1 int64) (int32, error)
    GetErrCollision(ctx context.Context, err int64) (int32, error)
    GetErr1Collision(ctx context.Context, err int64, err1 int64) (int32, error)
}

type GetEntityChannelClientInterface interface {
    thrift.ClientInterface
    GetEntity
}

type GetEntityClientInterface interface {
    thrift.ClientInterface
    GetEntity(r *GetEntityRequest) (*GetEntityResponse, error)
    GetBool() (bool, error)
    GetByte() (int8, error)
    GetI16() (int16, error)
    GetI32() (int32, error)
    GetI64() (int64, error)
    GetDouble() (float64, error)
    GetString() (string, error)
    GetBinary() ([]byte, error)
    GetMap() (map[string]string, error)
    GetSet() ([]string, error)
    GetList() ([]string, error)
    GetLegacyStuff(numPos int64, numNeg1 int64, numNeg2 int64) (int32, error)
    GetCtxCollision(ctx int64) (int32, error)
    GetCtx1Collision(ctx int64, ctx1 int64) (int32, error)
    GetContextCollision(context_ int64) (int32, error)
    GetOutCollision(out int64) (int32, error)
    GetOut1Collision(out int64, out1 int64) (int32, error)
    GetInCollision(in int64) (int32, error)
    GetIn1Collision(in int64, in1 int64) (int32, error)
    GetErrCollision(err int64) (int32, error)
    GetErr1Collision(err int64, err1 int64) (int32, error)
}

type GetEntityContextClientInterface interface {
    GetEntityClientInterface
    GetEntityContext(ctx context.Context, r *GetEntityRequest) (*GetEntityResponse, error)
    GetBoolContext(ctx context.Context) (bool, error)
    GetByteContext(ctx context.Context) (int8, error)
    GetI16Context(ctx context.Context) (int16, error)
    GetI32Context(ctx context.Context) (int32, error)
    GetI64Context(ctx context.Context) (int64, error)
    GetDoubleContext(ctx context.Context) (float64, error)
    GetStringContext(ctx context.Context) (string, error)
    GetBinaryContext(ctx context.Context) ([]byte, error)
    GetMapContext(ctx context.Context) (map[string]string, error)
    GetSetContext(ctx context.Context) ([]string, error)
    GetListContext(ctx context.Context) ([]string, error)
    GetLegacyStuffContext(ctx context.Context, numPos int64, numNeg1 int64, numNeg2 int64) (int32, error)
    GetCtxCollisionContext(ctx1 context.Context, ctx int64) (int32, error)
    GetCtx1CollisionContext(ctx2 context.Context, ctx int64, ctx1 int64) (int32, error)
    GetContextCollisionContext(ctx context.Context, context_ int64) (int32, error)
    GetOutCollisionContext(ctx context.Context, out int64) (int32, error)
    GetOut1CollisionContext(ctx context.Context, out int64, out1 int64) (int32, error)
    GetInCollisionContext(ctx context.Context, in int64) (int32, error)
    GetIn1CollisionContext(ctx context.Context, in int64, in1 int64) (int32, error)
    GetErrCollisionContext(ctx context.Context, err int64) (int32, error)
    GetErr1CollisionContext(ctx context.Context, err int64, err1 int64) (int32, error)
}

type GetEntityChannelClient struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ GetEntityChannelClientInterface = (*GetEntityChannelClient)(nil)

func NewGetEntityChannelClient(channel thrift.RequestChannel) *GetEntityChannelClient {
    return &GetEntityChannelClient{
        ch: channel,
    }
}

func (c *GetEntityChannelClient) Close() error {
    return c.ch.Close()
}

type GetEntityClient struct {
    chClient *GetEntityChannelClient
}
// Compile time interface enforcer
var _ GetEntityClientInterface = (*GetEntityClient)(nil)
var _ GetEntityContextClientInterface = (*GetEntityClient)(nil)

func NewGetEntityClient(prot thrift.Protocol) *GetEntityClient {
    return &GetEntityClient{
        chClient: NewGetEntityChannelClient(
            thrift.NewSerialChannel(prot),
        ),
    }
}

func (c *GetEntityClient) Close() error {
    return c.chClient.Close()
}

func (c *GetEntityChannelClient) GetEntity(ctx context.Context, r *GetEntityRequest) (*GetEntityResponse, error) {
    in := &reqGetEntityGetEntity{
        R: r,
    }
    out := newRespGetEntityGetEntity()
    err := c.ch.Call(ctx, "getEntity", in, out)
    if err != nil {
        return nil, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetEntity(r *GetEntityRequest) (*GetEntityResponse, error) {
    return c.chClient.GetEntity(context.Background(), r)
}

func (c *GetEntityClient) GetEntityContext(ctx context.Context, r *GetEntityRequest) (*GetEntityResponse, error) {
    return c.chClient.GetEntity(ctx, r)
}

func (c *GetEntityChannelClient) GetBool(ctx context.Context) (bool, error) {
    in := &reqGetEntityGetBool{
    }
    out := newRespGetEntityGetBool()
    err := c.ch.Call(ctx, "getBool", in, out)
    if err != nil {
        return false, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetBool() (bool, error) {
    return c.chClient.GetBool(context.Background())
}

func (c *GetEntityClient) GetBoolContext(ctx context.Context) (bool, error) {
    return c.chClient.GetBool(ctx)
}

func (c *GetEntityChannelClient) GetByte(ctx context.Context) (int8, error) {
    in := &reqGetEntityGetByte{
    }
    out := newRespGetEntityGetByte()
    err := c.ch.Call(ctx, "getByte", in, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetByte() (int8, error) {
    return c.chClient.GetByte(context.Background())
}

func (c *GetEntityClient) GetByteContext(ctx context.Context) (int8, error) {
    return c.chClient.GetByte(ctx)
}

func (c *GetEntityChannelClient) GetI16(ctx context.Context) (int16, error) {
    in := &reqGetEntityGetI16{
    }
    out := newRespGetEntityGetI16()
    err := c.ch.Call(ctx, "getI16", in, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetI16() (int16, error) {
    return c.chClient.GetI16(context.Background())
}

func (c *GetEntityClient) GetI16Context(ctx context.Context) (int16, error) {
    return c.chClient.GetI16(ctx)
}

func (c *GetEntityChannelClient) GetI32(ctx context.Context) (int32, error) {
    in := &reqGetEntityGetI32{
    }
    out := newRespGetEntityGetI32()
    err := c.ch.Call(ctx, "getI32", in, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetI32() (int32, error) {
    return c.chClient.GetI32(context.Background())
}

func (c *GetEntityClient) GetI32Context(ctx context.Context) (int32, error) {
    return c.chClient.GetI32(ctx)
}

func (c *GetEntityChannelClient) GetI64(ctx context.Context) (int64, error) {
    in := &reqGetEntityGetI64{
    }
    out := newRespGetEntityGetI64()
    err := c.ch.Call(ctx, "getI64", in, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetI64() (int64, error) {
    return c.chClient.GetI64(context.Background())
}

func (c *GetEntityClient) GetI64Context(ctx context.Context) (int64, error) {
    return c.chClient.GetI64(ctx)
}

func (c *GetEntityChannelClient) GetDouble(ctx context.Context) (float64, error) {
    in := &reqGetEntityGetDouble{
    }
    out := newRespGetEntityGetDouble()
    err := c.ch.Call(ctx, "getDouble", in, out)
    if err != nil {
        return 0.0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetDouble() (float64, error) {
    return c.chClient.GetDouble(context.Background())
}

func (c *GetEntityClient) GetDoubleContext(ctx context.Context) (float64, error) {
    return c.chClient.GetDouble(ctx)
}

func (c *GetEntityChannelClient) GetString(ctx context.Context) (string, error) {
    in := &reqGetEntityGetString{
    }
    out := newRespGetEntityGetString()
    err := c.ch.Call(ctx, "getString", in, out)
    if err != nil {
        return "", err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetString() (string, error) {
    return c.chClient.GetString(context.Background())
}

func (c *GetEntityClient) GetStringContext(ctx context.Context) (string, error) {
    return c.chClient.GetString(ctx)
}

func (c *GetEntityChannelClient) GetBinary(ctx context.Context) ([]byte, error) {
    in := &reqGetEntityGetBinary{
    }
    out := newRespGetEntityGetBinary()
    err := c.ch.Call(ctx, "getBinary", in, out)
    if err != nil {
        return nil, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetBinary() ([]byte, error) {
    return c.chClient.GetBinary(context.Background())
}

func (c *GetEntityClient) GetBinaryContext(ctx context.Context) ([]byte, error) {
    return c.chClient.GetBinary(ctx)
}

func (c *GetEntityChannelClient) GetMap(ctx context.Context) (map[string]string, error) {
    in := &reqGetEntityGetMap{
    }
    out := newRespGetEntityGetMap()
    err := c.ch.Call(ctx, "getMap", in, out)
    if err != nil {
        return nil, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetMap() (map[string]string, error) {
    return c.chClient.GetMap(context.Background())
}

func (c *GetEntityClient) GetMapContext(ctx context.Context) (map[string]string, error) {
    return c.chClient.GetMap(ctx)
}

func (c *GetEntityChannelClient) GetSet(ctx context.Context) ([]string, error) {
    in := &reqGetEntityGetSet{
    }
    out := newRespGetEntityGetSet()
    err := c.ch.Call(ctx, "getSet", in, out)
    if err != nil {
        return nil, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetSet() ([]string, error) {
    return c.chClient.GetSet(context.Background())
}

func (c *GetEntityClient) GetSetContext(ctx context.Context) ([]string, error) {
    return c.chClient.GetSet(ctx)
}

func (c *GetEntityChannelClient) GetList(ctx context.Context) ([]string, error) {
    in := &reqGetEntityGetList{
    }
    out := newRespGetEntityGetList()
    err := c.ch.Call(ctx, "getList", in, out)
    if err != nil {
        return nil, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetList() ([]string, error) {
    return c.chClient.GetList(context.Background())
}

func (c *GetEntityClient) GetListContext(ctx context.Context) ([]string, error) {
    return c.chClient.GetList(ctx)
}

func (c *GetEntityChannelClient) GetLegacyStuff(ctx context.Context, numPos int64, numNeg1 int64, numNeg2 int64) (int32, error) {
    in := &reqGetEntityGetLegacyStuff{
        NumPos: numPos,
        NumNeg1: numNeg1,
        NumNeg2: numNeg2,
    }
    out := newRespGetEntityGetLegacyStuff()
    err := c.ch.Call(ctx, "getLegacyStuff", in, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetLegacyStuff(numPos int64, numNeg1 int64, numNeg2 int64) (int32, error) {
    return c.chClient.GetLegacyStuff(context.Background(), numPos, numNeg1, numNeg2)
}

func (c *GetEntityClient) GetLegacyStuffContext(ctx context.Context, numPos int64, numNeg1 int64, numNeg2 int64) (int32, error) {
    return c.chClient.GetLegacyStuff(ctx, numPos, numNeg1, numNeg2)
}

func (c *GetEntityChannelClient) GetCtxCollision(ctx1 context.Context, ctx int64) (int32, error) {
    in := &reqGetEntityGetCtxCollision{
        Ctx: ctx,
    }
    out := newRespGetEntityGetCtxCollision()
    err := c.ch.Call(ctx1, "getCtxCollision", in, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetCtxCollision(ctx int64) (int32, error) {
    return c.chClient.GetCtxCollision(context.Background(), ctx)
}

func (c *GetEntityClient) GetCtxCollisionContext(ctx1 context.Context, ctx int64) (int32, error) {
    return c.chClient.GetCtxCollision(ctx1, ctx)
}

func (c *GetEntityChannelClient) GetCtx1Collision(ctx2 context.Context, ctx int64, ctx1 int64) (int32, error) {
    in := &reqGetEntityGetCtx1Collision{
        Ctx: ctx,
        Ctx1: ctx1,
    }
    out := newRespGetEntityGetCtx1Collision()
    err := c.ch.Call(ctx2, "getCtx1Collision", in, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetCtx1Collision(ctx int64, ctx1 int64) (int32, error) {
    return c.chClient.GetCtx1Collision(context.Background(), ctx, ctx1)
}

func (c *GetEntityClient) GetCtx1CollisionContext(ctx2 context.Context, ctx int64, ctx1 int64) (int32, error) {
    return c.chClient.GetCtx1Collision(ctx2, ctx, ctx1)
}

func (c *GetEntityChannelClient) GetContextCollision(ctx context.Context, context_ int64) (int32, error) {
    in := &reqGetEntityGetContextCollision{
        Context: context_,
    }
    out := newRespGetEntityGetContextCollision()
    err := c.ch.Call(ctx, "getContextCollision", in, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetContextCollision(context_ int64) (int32, error) {
    return c.chClient.GetContextCollision(context.Background(), context_)
}

func (c *GetEntityClient) GetContextCollisionContext(ctx context.Context, context_ int64) (int32, error) {
    return c.chClient.GetContextCollision(ctx, context_)
}

func (c *GetEntityChannelClient) GetOutCollision(ctx context.Context, out int64) (int32, error) {
    in := &reqGetEntityGetOutCollision{
        Out: out,
    }
    out1 := newRespGetEntityGetOutCollision()
    err := c.ch.Call(ctx, "getOutCollision", in, out1)
    if err != nil {
        return 0, err
    }
    return out1.GetSuccess(), nil
}

func (c *GetEntityClient) GetOutCollision(out int64) (int32, error) {
    return c.chClient.GetOutCollision(context.Background(), out)
}

func (c *GetEntityClient) GetOutCollisionContext(ctx context.Context, out int64) (int32, error) {
    return c.chClient.GetOutCollision(ctx, out)
}

func (c *GetEntityChannelClient) GetOut1Collision(ctx context.Context, out int64, out1 int64) (int32, error) {
    in := &reqGetEntityGetOut1Collision{
        Out: out,
        Out1: out1,
    }
    out2 := newRespGetEntityGetOut1Collision()
    err := c.ch.Call(ctx, "getOut1Collision", in, out2)
    if err != nil {
        return 0, err
    }
    return out2.GetSuccess(), nil
}

func (c *GetEntityClient) GetOut1Collision(out int64, out1 int64) (int32, error) {
    return c.chClient.GetOut1Collision(context.Background(), out, out1)
}

func (c *GetEntityClient) GetOut1CollisionContext(ctx context.Context, out int64, out1 int64) (int32, error) {
    return c.chClient.GetOut1Collision(ctx, out, out1)
}

func (c *GetEntityChannelClient) GetInCollision(ctx context.Context, in int64) (int32, error) {
    in1 := &reqGetEntityGetInCollision{
        In: in,
    }
    out := newRespGetEntityGetInCollision()
    err := c.ch.Call(ctx, "getInCollision", in1, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetInCollision(in int64) (int32, error) {
    return c.chClient.GetInCollision(context.Background(), in)
}

func (c *GetEntityClient) GetInCollisionContext(ctx context.Context, in int64) (int32, error) {
    return c.chClient.GetInCollision(ctx, in)
}

func (c *GetEntityChannelClient) GetIn1Collision(ctx context.Context, in int64, in1 int64) (int32, error) {
    in2 := &reqGetEntityGetIn1Collision{
        In: in,
        In1: in1,
    }
    out := newRespGetEntityGetIn1Collision()
    err := c.ch.Call(ctx, "getIn1Collision", in2, out)
    if err != nil {
        return 0, err
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetIn1Collision(in int64, in1 int64) (int32, error) {
    return c.chClient.GetIn1Collision(context.Background(), in, in1)
}

func (c *GetEntityClient) GetIn1CollisionContext(ctx context.Context, in int64, in1 int64) (int32, error) {
    return c.chClient.GetIn1Collision(ctx, in, in1)
}

func (c *GetEntityChannelClient) GetErrCollision(ctx context.Context, err int64) (int32, error) {
    in := &reqGetEntityGetErrCollision{
        Err: err,
    }
    out := newRespGetEntityGetErrCollision()
    err1 := c.ch.Call(ctx, "getErrCollision", in, out)
    if err1 != nil {
        return 0, err1
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetErrCollision(err int64) (int32, error) {
    return c.chClient.GetErrCollision(context.Background(), err)
}

func (c *GetEntityClient) GetErrCollisionContext(ctx context.Context, err int64) (int32, error) {
    return c.chClient.GetErrCollision(ctx, err)
}

func (c *GetEntityChannelClient) GetErr1Collision(ctx context.Context, err int64, err1 int64) (int32, error) {
    in := &reqGetEntityGetErr1Collision{
        Err: err,
        Err1: err1,
    }
    out := newRespGetEntityGetErr1Collision()
    err2 := c.ch.Call(ctx, "getErr1Collision", in, out)
    if err2 != nil {
        return 0, err2
    }
    return out.GetSuccess(), nil
}

func (c *GetEntityClient) GetErr1Collision(err int64, err1 int64) (int32, error) {
    return c.chClient.GetErr1Collision(context.Background(), err, err1)
}

func (c *GetEntityClient) GetErr1CollisionContext(ctx context.Context, err int64, err1 int64) (int32, error) {
    return c.chClient.GetErr1Collision(ctx, err, err1)
}


type GetEntityProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler            GetEntity
}

func NewGetEntityProcessor(handler GetEntity) *GetEntityProcessor {
    p := &GetEntityProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("getEntity", &procFuncGetEntityGetEntity{handler: handler})
    p.AddToProcessorFunctionMap("getBool", &procFuncGetEntityGetBool{handler: handler})
    p.AddToProcessorFunctionMap("getByte", &procFuncGetEntityGetByte{handler: handler})
    p.AddToProcessorFunctionMap("getI16", &procFuncGetEntityGetI16{handler: handler})
    p.AddToProcessorFunctionMap("getI32", &procFuncGetEntityGetI32{handler: handler})
    p.AddToProcessorFunctionMap("getI64", &procFuncGetEntityGetI64{handler: handler})
    p.AddToProcessorFunctionMap("getDouble", &procFuncGetEntityGetDouble{handler: handler})
    p.AddToProcessorFunctionMap("getString", &procFuncGetEntityGetString{handler: handler})
    p.AddToProcessorFunctionMap("getBinary", &procFuncGetEntityGetBinary{handler: handler})
    p.AddToProcessorFunctionMap("getMap", &procFuncGetEntityGetMap{handler: handler})
    p.AddToProcessorFunctionMap("getSet", &procFuncGetEntityGetSet{handler: handler})
    p.AddToProcessorFunctionMap("getList", &procFuncGetEntityGetList{handler: handler})
    p.AddToProcessorFunctionMap("getLegacyStuff", &procFuncGetEntityGetLegacyStuff{handler: handler})
    p.AddToProcessorFunctionMap("getCtxCollision", &procFuncGetEntityGetCtxCollision{handler: handler})
    p.AddToProcessorFunctionMap("getCtx1Collision", &procFuncGetEntityGetCtx1Collision{handler: handler})
    p.AddToProcessorFunctionMap("getContextCollision", &procFuncGetEntityGetContextCollision{handler: handler})
    p.AddToProcessorFunctionMap("getOutCollision", &procFuncGetEntityGetOutCollision{handler: handler})
    p.AddToProcessorFunctionMap("getOut1Collision", &procFuncGetEntityGetOut1Collision{handler: handler})
    p.AddToProcessorFunctionMap("getInCollision", &procFuncGetEntityGetInCollision{handler: handler})
    p.AddToProcessorFunctionMap("getIn1Collision", &procFuncGetEntityGetIn1Collision{handler: handler})
    p.AddToProcessorFunctionMap("getErrCollision", &procFuncGetEntityGetErrCollision{handler: handler})
    p.AddToProcessorFunctionMap("getErr1Collision", &procFuncGetEntityGetErr1Collision{handler: handler})
    p.AddToFunctionServiceMap("getEntity", "GetEntity")
    p.AddToFunctionServiceMap("getBool", "GetEntity")
    p.AddToFunctionServiceMap("getByte", "GetEntity")
    p.AddToFunctionServiceMap("getI16", "GetEntity")
    p.AddToFunctionServiceMap("getI32", "GetEntity")
    p.AddToFunctionServiceMap("getI64", "GetEntity")
    p.AddToFunctionServiceMap("getDouble", "GetEntity")
    p.AddToFunctionServiceMap("getString", "GetEntity")
    p.AddToFunctionServiceMap("getBinary", "GetEntity")
    p.AddToFunctionServiceMap("getMap", "GetEntity")
    p.AddToFunctionServiceMap("getSet", "GetEntity")
    p.AddToFunctionServiceMap("getList", "GetEntity")
    p.AddToFunctionServiceMap("getLegacyStuff", "GetEntity")
    p.AddToFunctionServiceMap("getCtxCollision", "GetEntity")
    p.AddToFunctionServiceMap("getCtx1Collision", "GetEntity")
    p.AddToFunctionServiceMap("getContextCollision", "GetEntity")
    p.AddToFunctionServiceMap("getOutCollision", "GetEntity")
    p.AddToFunctionServiceMap("getOut1Collision", "GetEntity")
    p.AddToFunctionServiceMap("getInCollision", "GetEntity")
    p.AddToFunctionServiceMap("getIn1Collision", "GetEntity")
    p.AddToFunctionServiceMap("getErrCollision", "GetEntity")
    p.AddToFunctionServiceMap("getErr1Collision", "GetEntity")

    return p
}

func (p *GetEntityProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *GetEntityProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *GetEntityProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *GetEntityProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *GetEntityProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *GetEntityProcessor) PackageName() string {
    return "module"
}

func (p *GetEntityProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.GetEntity")
}


type procFuncGetEntityGetEntity struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetEntity)(nil)

func (p *procFuncGetEntityGetEntity) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetEntity()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetEntity) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getEntity", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetEntity) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetEntity)
    result := newRespGetEntityGetEntity()
    retval, err := p.handler.GetEntity(ctx, args.R)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetEntity: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetBool struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetBool)(nil)

func (p *procFuncGetEntityGetBool) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetBool()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetBool) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getBool", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetBool) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetBool()
    retval, err := p.handler.GetBool(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetBool: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetByte struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetByte)(nil)

func (p *procFuncGetEntityGetByte) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetByte()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetByte) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getByte", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetByte) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetByte()
    retval, err := p.handler.GetByte(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetByte: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetI16 struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetI16)(nil)

func (p *procFuncGetEntityGetI16) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetI16()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetI16) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getI16", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetI16) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetI16()
    retval, err := p.handler.GetI16(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetI16: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetI32 struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetI32)(nil)

func (p *procFuncGetEntityGetI32) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetI32()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetI32) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getI32", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetI32) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetI32()
    retval, err := p.handler.GetI32(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetI32: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetI64 struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetI64)(nil)

func (p *procFuncGetEntityGetI64) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetI64()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetI64) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getI64", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetI64) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetI64()
    retval, err := p.handler.GetI64(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetI64: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetDouble struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetDouble)(nil)

func (p *procFuncGetEntityGetDouble) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetDouble()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetDouble) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getDouble", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetDouble) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetDouble()
    retval, err := p.handler.GetDouble(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetDouble: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetString struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetString)(nil)

func (p *procFuncGetEntityGetString) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetString()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetString) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getString", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetString) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetString()
    retval, err := p.handler.GetString(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetString: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetBinary struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetBinary)(nil)

func (p *procFuncGetEntityGetBinary) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetBinary()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetBinary) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getBinary", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetBinary) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetBinary()
    retval, err := p.handler.GetBinary(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetBinary: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetMap struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetMap)(nil)

func (p *procFuncGetEntityGetMap) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetMap()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetMap) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getMap", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetMap) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetMap()
    retval, err := p.handler.GetMap(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetMap: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetSet struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetSet)(nil)

func (p *procFuncGetEntityGetSet) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetSet()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetSet) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getSet", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetSet) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetSet()
    retval, err := p.handler.GetSet(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetSet: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetList struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetList)(nil)

func (p *procFuncGetEntityGetList) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetList()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetList) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getList", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetList) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespGetEntityGetList()
    retval, err := p.handler.GetList(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetList: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncGetEntityGetLegacyStuff struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetLegacyStuff)(nil)

func (p *procFuncGetEntityGetLegacyStuff) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetLegacyStuff()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetLegacyStuff) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getLegacyStuff", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetLegacyStuff) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetLegacyStuff)
    result := newRespGetEntityGetLegacyStuff()
    retval, err := p.handler.GetLegacyStuff(ctx, args.NumPos, args.NumNeg1, args.NumNeg2)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetLegacyStuff: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetCtxCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetCtxCollision)(nil)

func (p *procFuncGetEntityGetCtxCollision) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetCtxCollision()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetCtxCollision) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getCtxCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetCtxCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetCtxCollision)
    result := newRespGetEntityGetCtxCollision()
    retval, err := p.handler.GetCtxCollision(ctx, args.Ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetCtxCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetCtx1Collision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetCtx1Collision)(nil)

func (p *procFuncGetEntityGetCtx1Collision) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetCtx1Collision()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetCtx1Collision) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getCtx1Collision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetCtx1Collision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetCtx1Collision)
    result := newRespGetEntityGetCtx1Collision()
    retval, err := p.handler.GetCtx1Collision(ctx, args.Ctx, args.Ctx1)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetCtx1Collision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetContextCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetContextCollision)(nil)

func (p *procFuncGetEntityGetContextCollision) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetContextCollision()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetContextCollision) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getContextCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetContextCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetContextCollision)
    result := newRespGetEntityGetContextCollision()
    retval, err := p.handler.GetContextCollision(ctx, args.Context)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetContextCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetOutCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetOutCollision)(nil)

func (p *procFuncGetEntityGetOutCollision) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetOutCollision()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetOutCollision) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getOutCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetOutCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetOutCollision)
    result := newRespGetEntityGetOutCollision()
    retval, err := p.handler.GetOutCollision(ctx, args.Out)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetOutCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetOut1Collision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetOut1Collision)(nil)

func (p *procFuncGetEntityGetOut1Collision) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetOut1Collision()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetOut1Collision) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getOut1Collision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetOut1Collision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetOut1Collision)
    result := newRespGetEntityGetOut1Collision()
    retval, err := p.handler.GetOut1Collision(ctx, args.Out, args.Out1)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetOut1Collision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetInCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetInCollision)(nil)

func (p *procFuncGetEntityGetInCollision) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetInCollision()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetInCollision) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getInCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetInCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetInCollision)
    result := newRespGetEntityGetInCollision()
    retval, err := p.handler.GetInCollision(ctx, args.In)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetInCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetIn1Collision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetIn1Collision)(nil)

func (p *procFuncGetEntityGetIn1Collision) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetIn1Collision()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetIn1Collision) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getIn1Collision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetIn1Collision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetIn1Collision)
    result := newRespGetEntityGetIn1Collision()
    retval, err := p.handler.GetIn1Collision(ctx, args.In, args.In1)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetIn1Collision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetErrCollision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetErrCollision)(nil)

func (p *procFuncGetEntityGetErrCollision) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetErrCollision()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetErrCollision) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getErrCollision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetErrCollision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetErrCollision)
    result := newRespGetEntityGetErrCollision()
    retval, err := p.handler.GetErrCollision(ctx, args.Err)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetErrCollision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncGetEntityGetErr1Collision struct {
    handler GetEntity
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncGetEntityGetErr1Collision)(nil)

func (p *procFuncGetEntityGetErr1Collision) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqGetEntityGetErr1Collision()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncGetEntityGetErr1Collision) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getErr1Collision", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncGetEntityGetErr1Collision) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqGetEntityGetErr1Collision)
    result := newRespGetEntityGetErr1Collision()
    retval, err := p.handler.GetErr1Collision(ctx, args.Err, args.Err1)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetErr1Collision: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


