// Autogenerated by Thrift for thrift/annotation/cpp.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package cpp

import (
    "fmt"
    "reflect"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
)

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = reflect.Ptr
var _ = thrift.ZERO


type RefType int32

const (
    RefType_Unique RefType = 0
    RefType_Shared RefType = 1
    RefType_SharedMutable RefType = 2
)

// Enum value maps for RefType
var (
    RefTypeToName = map[RefType]string {
        RefType_Unique: "Unique",
        RefType_Shared: "Shared",
        RefType_SharedMutable: "SharedMutable",
    }

    RefTypeToValue = map[string]RefType {
        "Unique": RefType_Unique,
        "Shared": RefType_Shared,
        "SharedMutable": RefType_SharedMutable,
    }
)

func (x RefType) String() string {
    if v, ok := RefTypeToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x RefType) Ptr() *RefType {
    return &x
}

// Deprecated: Use RefTypeToValue instead (e.g. `x, ok := RefTypeToValue["name"]`).
func RefTypeFromString(s string) (RefType, error) {
    if v, ok := RefTypeToValue[s]; ok {
        return v, nil
    }
    return RefType(0), fmt.Errorf("not a valid RefType string")
}


type EnumUnderlyingType int32

const (
    EnumUnderlyingType_I8 EnumUnderlyingType = 0
    EnumUnderlyingType_U8 EnumUnderlyingType = 1
    EnumUnderlyingType_I16 EnumUnderlyingType = 2
    EnumUnderlyingType_U16 EnumUnderlyingType = 3
    EnumUnderlyingType_U32 EnumUnderlyingType = 4
)

// Enum value maps for EnumUnderlyingType
var (
    EnumUnderlyingTypeToName = map[EnumUnderlyingType]string {
        EnumUnderlyingType_I8: "I8",
        EnumUnderlyingType_U8: "U8",
        EnumUnderlyingType_I16: "I16",
        EnumUnderlyingType_U16: "U16",
        EnumUnderlyingType_U32: "U32",
    }

    EnumUnderlyingTypeToValue = map[string]EnumUnderlyingType {
        "I8": EnumUnderlyingType_I8,
        "U8": EnumUnderlyingType_U8,
        "I16": EnumUnderlyingType_I16,
        "U16": EnumUnderlyingType_U16,
        "U32": EnumUnderlyingType_U32,
    }
)

func (x EnumUnderlyingType) String() string {
    if v, ok := EnumUnderlyingTypeToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x EnumUnderlyingType) Ptr() *EnumUnderlyingType {
    return &x
}

// Deprecated: Use EnumUnderlyingTypeToValue instead (e.g. `x, ok := EnumUnderlyingTypeToValue["name"]`).
func EnumUnderlyingTypeFromString(s string) (EnumUnderlyingType, error) {
    if v, ok := EnumUnderlyingTypeToValue[s]; ok {
        return v, nil
    }
    return EnumUnderlyingType(0), fmt.Errorf("not a valid EnumUnderlyingType string")
}

type Name struct {
    Value string `thrift:"value,1" json:"value" db:"value"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Name)(nil)

func NewName() *Name {
    return (&Name{}).setDefaults()
}

func (x *Name) GetValue() string {
    return x.Value
}

func (x *Name) SetValueNonCompat(value string) *Name {
    x.Value = value
    return x
}

func (x *Name) SetValue(value string) *Name {
    x.Value = value
    return x
}

func (x *Name) writeField1(p thrift.Encoder) error {  // Value
    if err := p.WriteFieldBegin("value", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Value
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Name) readField1(p thrift.Decoder) error {  // Value
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.Value = result
    return nil
}



func (x *Name) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Name"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Name) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "value")):  // value
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Name) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *Name) setDefaults() *Name {
    return x.
        SetValueNonCompat("")
}

type Type struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    Template string `thrift:"template,2" json:"template" db:"template"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Type)(nil)

func NewType() *Type {
    return (&Type{}).setDefaults()
}

func (x *Type) GetName() string {
    return x.Name
}

func (x *Type) GetTemplate() string {
    return x.Template
}

func (x *Type) SetNameNonCompat(value string) *Type {
    x.Name = value
    return x
}

func (x *Type) SetName(value string) *Type {
    x.Name = value
    return x
}

func (x *Type) SetTemplateNonCompat(value string) *Type {
    x.Template = value
    return x
}

func (x *Type) SetTemplate(value string) *Type {
    x.Template = value
    return x
}

func (x *Type) writeField1(p thrift.Encoder) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Name
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Type) writeField2(p thrift.Encoder) error {  // Template
    if err := p.WriteFieldBegin("template", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Template
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Type) readField1(p thrift.Decoder) error {  // Name
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.Name = result
    return nil
}

func (x *Type) readField2(p thrift.Decoder) error {  // Template
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.Template = result
    return nil
}



func (x *Type) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Type"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Type) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "name")):  // name
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "template")):  // template
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Type) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *Type) setDefaults() *Type {
    return x.
        SetNameNonCompat("").
        SetTemplateNonCompat("")
}

type Ref struct {
    Type RefType `thrift:"type,1" json:"type" db:"type"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Ref)(nil)

func NewRef() *Ref {
    return (&Ref{}).setDefaults()
}

func (x *Ref) GetType() RefType {
    return x.Type
}

func (x *Ref) SetTypeNonCompat(value RefType) *Ref {
    x.Type = value
    return x
}

func (x *Ref) SetType(value RefType) *Ref {
    x.Type = value
    return x
}

func (x *Ref) writeField1(p thrift.Encoder) error {  // Type
    if err := p.WriteFieldBegin("type", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Type
    if err := p.WriteI32(int32(item)); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Ref) readField1(p thrift.Decoder) error {  // Type
    enumResult, err := p.ReadI32()
    if err != nil {
        return err
    }
    result := RefType(enumResult)

    x.Type = result
    return nil
}



func (x *Ref) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Ref"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Ref) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "type")):  // type
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Ref) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *Ref) setDefaults() *Ref {
    return x.
        SetTypeNonCompat(0)
}

type Lazy struct {
    Ref bool `thrift:"ref,1" json:"ref" db:"ref"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Lazy)(nil)

func NewLazy() *Lazy {
    return (&Lazy{}).setDefaults()
}

func (x *Lazy) GetRef() bool {
    return x.Ref
}

func (x *Lazy) SetRefNonCompat(value bool) *Lazy {
    x.Ref = value
    return x
}

func (x *Lazy) SetRef(value bool) *Lazy {
    x.Ref = value
    return x
}

func (x *Lazy) writeField1(p thrift.Encoder) error {  // Ref
    if err := p.WriteFieldBegin("ref", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Ref
    if err := p.WriteBool(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Lazy) readField1(p thrift.Decoder) error {  // Ref
    result, err := p.ReadBool()
    if err != nil {
        return err
    }

    x.Ref = result
    return nil
}



func (x *Lazy) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Lazy"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Lazy) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.BOOL) || (id == thrift.NO_FIELD_ID && fieldName == "ref")):  // ref
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Lazy) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *Lazy) setDefaults() *Lazy {
    return x.
        SetRefNonCompat(false)
}

type DisableLazyChecksum struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*DisableLazyChecksum)(nil)

func NewDisableLazyChecksum() *DisableLazyChecksum {
    return (&DisableLazyChecksum{}).setDefaults()
}



func (x *DisableLazyChecksum) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("DisableLazyChecksum"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DisableLazyChecksum) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DisableLazyChecksum) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *DisableLazyChecksum) setDefaults() *DisableLazyChecksum {
    return x
}

type Adapter struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    AdaptedType string `thrift:"adaptedType,2" json:"adaptedType" db:"adaptedType"`
    UnderlyingName string `thrift:"underlyingName,3" json:"underlyingName" db:"underlyingName"`
    ExtraNamespace string `thrift:"extraNamespace,4" json:"extraNamespace" db:"extraNamespace"`
    MoveOnly bool `thrift:"moveOnly,5" json:"moveOnly" db:"moveOnly"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Adapter)(nil)

func NewAdapter() *Adapter {
    return (&Adapter{}).setDefaults()
}

func (x *Adapter) GetName() string {
    return x.Name
}

func (x *Adapter) GetAdaptedType() string {
    return x.AdaptedType
}

func (x *Adapter) GetUnderlyingName() string {
    return x.UnderlyingName
}

func (x *Adapter) GetExtraNamespace() string {
    return x.ExtraNamespace
}

func (x *Adapter) GetMoveOnly() bool {
    return x.MoveOnly
}

func (x *Adapter) SetNameNonCompat(value string) *Adapter {
    x.Name = value
    return x
}

func (x *Adapter) SetName(value string) *Adapter {
    x.Name = value
    return x
}

func (x *Adapter) SetAdaptedTypeNonCompat(value string) *Adapter {
    x.AdaptedType = value
    return x
}

func (x *Adapter) SetAdaptedType(value string) *Adapter {
    x.AdaptedType = value
    return x
}

func (x *Adapter) SetUnderlyingNameNonCompat(value string) *Adapter {
    x.UnderlyingName = value
    return x
}

func (x *Adapter) SetUnderlyingName(value string) *Adapter {
    x.UnderlyingName = value
    return x
}

func (x *Adapter) SetExtraNamespaceNonCompat(value string) *Adapter {
    x.ExtraNamespace = value
    return x
}

func (x *Adapter) SetExtraNamespace(value string) *Adapter {
    x.ExtraNamespace = value
    return x
}

func (x *Adapter) SetMoveOnlyNonCompat(value bool) *Adapter {
    x.MoveOnly = value
    return x
}

func (x *Adapter) SetMoveOnly(value bool) *Adapter {
    x.MoveOnly = value
    return x
}

func (x *Adapter) writeField1(p thrift.Encoder) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Name
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField2(p thrift.Encoder) error {  // AdaptedType
    if err := p.WriteFieldBegin("adaptedType", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.AdaptedType
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField3(p thrift.Encoder) error {  // UnderlyingName
    if err := p.WriteFieldBegin("underlyingName", thrift.STRING, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.UnderlyingName
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField4(p thrift.Encoder) error {  // ExtraNamespace
    if err := p.WriteFieldBegin("extraNamespace", thrift.STRING, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.ExtraNamespace
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField5(p thrift.Encoder) error {  // MoveOnly
    if err := p.WriteFieldBegin("moveOnly", thrift.BOOL, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.MoveOnly
    if err := p.WriteBool(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) readField1(p thrift.Decoder) error {  // Name
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.Name = result
    return nil
}

func (x *Adapter) readField2(p thrift.Decoder) error {  // AdaptedType
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.AdaptedType = result
    return nil
}

func (x *Adapter) readField3(p thrift.Decoder) error {  // UnderlyingName
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.UnderlyingName = result
    return nil
}

func (x *Adapter) readField4(p thrift.Decoder) error {  // ExtraNamespace
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.ExtraNamespace = result
    return nil
}

func (x *Adapter) readField5(p thrift.Decoder) error {  // MoveOnly
    result, err := p.ReadBool()
    if err != nil {
        return err
    }

    x.MoveOnly = result
    return nil
}



func (x *Adapter) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Adapter"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }
    if err := x.writeField3(p); err != nil {
        return err
    }
    if err := x.writeField4(p); err != nil {
        return err
    }
    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Adapter) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "name")):  // name
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "adaptedType")):  // adaptedType
            fieldReadErr = x.readField2(p)
        case ((id == 3 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "underlyingName")):  // underlyingName
            fieldReadErr = x.readField3(p)
        case ((id == 4 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "extraNamespace")):  // extraNamespace
            fieldReadErr = x.readField4(p)
        case ((id == 5 && wireType == thrift.BOOL) || (id == thrift.NO_FIELD_ID && fieldName == "moveOnly")):  // moveOnly
            fieldReadErr = x.readField5(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Adapter) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *Adapter) setDefaults() *Adapter {
    return x.
        SetNameNonCompat("").
        SetAdaptedTypeNonCompat("").
        SetUnderlyingNameNonCompat("").
        SetExtraNamespaceNonCompat("").
        SetMoveOnlyNonCompat(false)
}

type PackIsset struct {
    Atomic bool `thrift:"atomic,1" json:"atomic" db:"atomic"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*PackIsset)(nil)

func NewPackIsset() *PackIsset {
    return (&PackIsset{}).setDefaults()
}

func (x *PackIsset) GetAtomic() bool {
    return x.Atomic
}

func (x *PackIsset) SetAtomicNonCompat(value bool) *PackIsset {
    x.Atomic = value
    return x
}

func (x *PackIsset) SetAtomic(value bool) *PackIsset {
    x.Atomic = value
    return x
}

func (x *PackIsset) writeField1(p thrift.Encoder) error {  // Atomic
    if err := p.WriteFieldBegin("atomic", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Atomic
    if err := p.WriteBool(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *PackIsset) readField1(p thrift.Decoder) error {  // Atomic
    result, err := p.ReadBool()
    if err != nil {
        return err
    }

    x.Atomic = result
    return nil
}



func (x *PackIsset) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("PackIsset"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *PackIsset) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.BOOL) || (id == thrift.NO_FIELD_ID && fieldName == "atomic")):  // atomic
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *PackIsset) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *PackIsset) setDefaults() *PackIsset {
    return x.
        SetAtomicNonCompat(true)
}

type MinimizePadding struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*MinimizePadding)(nil)

func NewMinimizePadding() *MinimizePadding {
    return (&MinimizePadding{}).setDefaults()
}



func (x *MinimizePadding) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("MinimizePadding"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinimizePadding) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MinimizePadding) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *MinimizePadding) setDefaults() *MinimizePadding {
    return x
}

type ScopedEnumAsUnionType struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*ScopedEnumAsUnionType)(nil)

func NewScopedEnumAsUnionType() *ScopedEnumAsUnionType {
    return (&ScopedEnumAsUnionType{}).setDefaults()
}



func (x *ScopedEnumAsUnionType) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ScopedEnumAsUnionType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ScopedEnumAsUnionType) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ScopedEnumAsUnionType) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ScopedEnumAsUnionType) setDefaults() *ScopedEnumAsUnionType {
    return x
}

type FieldInterceptor struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    Noinline bool `thrift:"noinline,2" json:"noinline" db:"noinline"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*FieldInterceptor)(nil)

func NewFieldInterceptor() *FieldInterceptor {
    return (&FieldInterceptor{}).setDefaults()
}

func (x *FieldInterceptor) GetName() string {
    return x.Name
}

func (x *FieldInterceptor) GetNoinline() bool {
    return x.Noinline
}

func (x *FieldInterceptor) SetNameNonCompat(value string) *FieldInterceptor {
    x.Name = value
    return x
}

func (x *FieldInterceptor) SetName(value string) *FieldInterceptor {
    x.Name = value
    return x
}

func (x *FieldInterceptor) SetNoinlineNonCompat(value bool) *FieldInterceptor {
    x.Noinline = value
    return x
}

func (x *FieldInterceptor) SetNoinline(value bool) *FieldInterceptor {
    x.Noinline = value
    return x
}

func (x *FieldInterceptor) writeField1(p thrift.Encoder) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Name
    if err := p.WriteString(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) writeField2(p thrift.Encoder) error {  // Noinline
    if err := p.WriteFieldBegin("noinline", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Noinline
    if err := p.WriteBool(item); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) readField1(p thrift.Decoder) error {  // Name
    result, err := p.ReadString()
    if err != nil {
        return err
    }

    x.Name = result
    return nil
}

func (x *FieldInterceptor) readField2(p thrift.Decoder) error {  // Noinline
    result, err := p.ReadBool()
    if err != nil {
        return err
    }

    x.Noinline = result
    return nil
}



func (x *FieldInterceptor) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("FieldInterceptor"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }
    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.STRING) || (id == thrift.NO_FIELD_ID && fieldName == "name")):  // name
            fieldReadErr = x.readField1(p)
        case ((id == 2 && wireType == thrift.BOOL) || (id == thrift.NO_FIELD_ID && fieldName == "noinline")):  // noinline
            fieldReadErr = x.readField2(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *FieldInterceptor) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *FieldInterceptor) setDefaults() *FieldInterceptor {
    return x.
        SetNameNonCompat("").
        SetNoinlineNonCompat(false)
}

type UseOpEncode struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*UseOpEncode)(nil)

func NewUseOpEncode() *UseOpEncode {
    return (&UseOpEncode{}).setDefaults()
}



func (x *UseOpEncode) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("UseOpEncode"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *UseOpEncode) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *UseOpEncode) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *UseOpEncode) setDefaults() *UseOpEncode {
    return x
}

type EnumType struct {
    Type EnumUnderlyingType `thrift:"type,1" json:"type" db:"type"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*EnumType)(nil)

func NewEnumType() *EnumType {
    return (&EnumType{}).setDefaults()
}

func (x *EnumType) GetType() EnumUnderlyingType {
    return x.Type
}

func (x *EnumType) SetTypeNonCompat(value EnumUnderlyingType) *EnumType {
    x.Type = value
    return x
}

func (x *EnumType) SetType(value EnumUnderlyingType) *EnumType {
    x.Type = value
    return x
}

func (x *EnumType) writeField1(p thrift.Encoder) error {  // Type
    if err := p.WriteFieldBegin("type", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Type
    if err := p.WriteI32(int32(item)); err != nil {
        return err
    }

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *EnumType) readField1(p thrift.Decoder) error {  // Type
    enumResult, err := p.ReadI32()
    if err != nil {
        return err
    }
    result := EnumUnderlyingType(enumResult)

    x.Type = result
    return nil
}



func (x *EnumType) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("EnumType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *EnumType) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        case ((id == 1 && wireType == thrift.I32) || (id == thrift.NO_FIELD_ID && fieldName == "type")):  // type
            fieldReadErr = x.readField1(p)
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *EnumType) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *EnumType) setDefaults() *EnumType {
    return x.
        SetTypeNonCompat(0)
}

type Frozen2Exclude struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*Frozen2Exclude)(nil)

func NewFrozen2Exclude() *Frozen2Exclude {
    return (&Frozen2Exclude{}).setDefaults()
}



func (x *Frozen2Exclude) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Frozen2Exclude"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Frozen2Exclude) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Frozen2Exclude) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *Frozen2Exclude) setDefaults() *Frozen2Exclude {
    return x
}

type Frozen2RequiresCompleteContainerParams struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*Frozen2RequiresCompleteContainerParams)(nil)

func NewFrozen2RequiresCompleteContainerParams() *Frozen2RequiresCompleteContainerParams {
    return (&Frozen2RequiresCompleteContainerParams{}).setDefaults()
}



func (x *Frozen2RequiresCompleteContainerParams) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Frozen2RequiresCompleteContainerParams"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Frozen2RequiresCompleteContainerParams) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Frozen2RequiresCompleteContainerParams) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *Frozen2RequiresCompleteContainerParams) setDefaults() *Frozen2RequiresCompleteContainerParams {
    return x
}

type ProcessInEbThreadUnsafe struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*ProcessInEbThreadUnsafe)(nil)

func NewProcessInEbThreadUnsafe() *ProcessInEbThreadUnsafe {
    return (&ProcessInEbThreadUnsafe{}).setDefaults()
}



func (x *ProcessInEbThreadUnsafe) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ProcessInEbThreadUnsafe"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ProcessInEbThreadUnsafe) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ProcessInEbThreadUnsafe) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *ProcessInEbThreadUnsafe) setDefaults() *ProcessInEbThreadUnsafe {
    return x
}

type RuntimeAnnotation struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*RuntimeAnnotation)(nil)

func NewRuntimeAnnotation() *RuntimeAnnotation {
    return (&RuntimeAnnotation{}).setDefaults()
}



func (x *RuntimeAnnotation) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("RuntimeAnnotation"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *RuntimeAnnotation) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *RuntimeAnnotation) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *RuntimeAnnotation) setDefaults() *RuntimeAnnotation {
    return x
}

type UseCursorSerialization struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*UseCursorSerialization)(nil)

func NewUseCursorSerialization() *UseCursorSerialization {
    return (&UseCursorSerialization{}).setDefaults()
}



func (x *UseCursorSerialization) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("UseCursorSerialization"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *UseCursorSerialization) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *UseCursorSerialization) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *UseCursorSerialization) setDefaults() *UseCursorSerialization {
    return x
}

type GenerateDeprecatedHeaderClientMethods struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*GenerateDeprecatedHeaderClientMethods)(nil)

func NewGenerateDeprecatedHeaderClientMethods() *GenerateDeprecatedHeaderClientMethods {
    return (&GenerateDeprecatedHeaderClientMethods{}).setDefaults()
}



func (x *GenerateDeprecatedHeaderClientMethods) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("GenerateDeprecatedHeaderClientMethods"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *GenerateDeprecatedHeaderClientMethods) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *GenerateDeprecatedHeaderClientMethods) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *GenerateDeprecatedHeaderClientMethods) setDefaults() *GenerateDeprecatedHeaderClientMethods {
    return x
}

type AllowLegacyNonOptionalRef struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*AllowLegacyNonOptionalRef)(nil)

func NewAllowLegacyNonOptionalRef() *AllowLegacyNonOptionalRef {
    return (&AllowLegacyNonOptionalRef{}).setDefaults()
}



func (x *AllowLegacyNonOptionalRef) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("AllowLegacyNonOptionalRef"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }


    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AllowLegacyNonOptionalRef) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        fieldName, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d ('%s') read error: ", x, id, fieldName), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        var fieldReadErr error
        switch {
        default:
            fieldReadErr = p.Skip(wireType)
        }

        if fieldReadErr != nil {
            return fieldReadErr
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AllowLegacyNonOptionalRef) String() string {
    return thrift.StructToString(reflect.ValueOf(x))
}

func (x *AllowLegacyNonOptionalRef) setDefaults() *AllowLegacyNonOptionalRef {
    return x
}



// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
  RegisterType(name string, initializer func() any)
}) {
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Name", func() any { return NewName() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Type", func() any { return NewType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Ref", func() any { return NewRef() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Lazy", func() any { return NewLazy() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/DisableLazyChecksum", func() any { return NewDisableLazyChecksum() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Adapter", func() any { return NewAdapter() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/PackIsset", func() any { return NewPackIsset() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/MinimizePadding", func() any { return NewMinimizePadding() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/ScopedEnumAsUnionType", func() any { return NewScopedEnumAsUnionType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/FieldInterceptor", func() any { return NewFieldInterceptor() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/UseOpEncode", func() any { return NewUseOpEncode() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/EnumType", func() any { return NewEnumType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Frozen2Exclude", func() any { return NewFrozen2Exclude() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Frozen2RequiresCompleteContainerParams", func() any { return NewFrozen2RequiresCompleteContainerParams() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/ProcessInEbThreadUnsafe", func() any { return NewProcessInEbThreadUnsafe() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/RuntimeAnnotation", func() any { return NewRuntimeAnnotation() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/UseCursorSerialization", func() any { return NewUseCursorSerialization() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/GenerateDeprecatedHeaderClientMethods", func() any { return NewGenerateDeprecatedHeaderClientMethods() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/AllowLegacyNonOptionalRef", func() any { return NewAllowLegacyNonOptionalRef() })

    registry.RegisterType("facebook.com/thrift/annotation/cpp/RefType", func() any { return RefType(0) })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/EnumUnderlyingType", func() any { return EnumUnderlyingType(0) })
}
