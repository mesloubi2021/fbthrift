#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/basic-enum/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import thrift.py3.types
import importlib
from collections.abc import Mapping, Sequence, Set

"""
    This is a helper module to define py3 container types.
    All types defined here are re-exported in the parent `.types` module.
    Only `import` types defined here via the parent `.types` module.
    If you `import` them directly from here, you will get nasty import errors.
"""

_fbthrift__module_name__ = "test.fixtures.enumstrict.module.types"

import test.fixtures.enumstrict.module.types as _test_fixtures_enumstrict_module_types

def get_types_reflection():
    return importlib.import_module(
        "test.fixtures.enumstrict.module.types_reflection"
    )

__all__ = []

class Map__MyEnum_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__MyEnum_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__MyEnum_string._check_key_type_or_raise
            check_val = Map__MyEnum_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__MyEnum_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, _test_fixtures_enumstrict_module_types.MyEnum) or
            isinstance(key, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{key!r} is not of type _test_fixtures_enumstrict_module_types.MyEnum")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, _test_fixtures_enumstrict_module_types.MyEnum):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__MyEnum_string()


Mapping.register(Map__MyEnum_string)
__all__.append('Map__MyEnum_string')


