// Autogenerated by Thrift for thrift/compiler/test/fixtures/basic/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module


import (
    "context"
    "fmt"
    "reflect"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
    metadata "github.com/facebook/fbthrift/thrift/lib/thrift/metadata"
)

// (needed to ensure safety because of naive import list construction)
var _ = context.Background
var _ = fmt.Printf
var _ = reflect.Ptr
var _ = thrift.ZERO
var _ = metadata.GoUnusedProtection__

type FooService interface {
    SimpleRPC(ctx context.Context) (error)
}

type FooServiceChannelClientInterface interface {
    thrift.ClientInterface
    FooService
}

type FooServiceClientInterface interface {
    thrift.ClientInterface
    SimpleRPC() (error)
}

type FooServiceContextClientInterface interface {
    FooServiceClientInterface
    SimpleRPCContext(ctx context.Context) (error)
}

type FooServiceChannelClient struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ FooServiceChannelClientInterface = (*FooServiceChannelClient)(nil)

func NewFooServiceChannelClient(channel thrift.RequestChannel) *FooServiceChannelClient {
    return &FooServiceChannelClient{
        ch: channel,
    }
}

func (c *FooServiceChannelClient) Close() error {
    return c.ch.Close()
}

type FooServiceClient struct {
    chClient *FooServiceChannelClient
}
// Compile time interface enforcer
var _ FooServiceClientInterface = (*FooServiceClient)(nil)
var _ FooServiceContextClientInterface = (*FooServiceClient)(nil)

func NewFooServiceClient(prot thrift.Protocol) *FooServiceClient {
    return &FooServiceClient{
        chClient: NewFooServiceChannelClient(
            thrift.NewSerialChannel(prot),
        ),
    }
}

func (c *FooServiceClient) Close() error {
    return c.chClient.Close()
}

func (c *FooServiceChannelClient) SimpleRPC(ctx context.Context) (error) {
    in := &reqFooServiceSimpleRPC{
    }
    out := newRespFooServiceSimpleRPC()
    err := c.ch.Call(ctx, "simple_rpc", in, out)
    if err != nil {
        return err
    }
    return nil
}

func (c *FooServiceClient) SimpleRPC() (error) {
    return c.chClient.SimpleRPC(context.Background())
}

func (c *FooServiceClient) SimpleRPCContext(ctx context.Context) (error) {
    return c.chClient.SimpleRPC(ctx)
}


type FooServiceProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler            FooService
}

func NewFooServiceProcessor(handler FooService) *FooServiceProcessor {
    p := &FooServiceProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("simple_rpc", &procFuncFooServiceSimpleRPC{handler: handler})
    p.AddToFunctionServiceMap("simple_rpc", "FooService")

    return p
}

func (p *FooServiceProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *FooServiceProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *FooServiceProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *FooServiceProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *FooServiceProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *FooServiceProcessor) PackageName() string {
    return "module"
}

func (p *FooServiceProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.FooService")
}


type procFuncFooServiceSimpleRPC struct {
    handler FooService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncFooServiceSimpleRPC)(nil)

func (p *procFuncFooServiceSimpleRPC) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqFooServiceSimpleRPC()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncFooServiceSimpleRPC) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("simple_rpc", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncFooServiceSimpleRPC) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespFooServiceSimpleRPC()
    err := p.handler.SimpleRPC(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing SimpleRPC: " + err.Error(), err)
        return x, x
    }

    return result, nil
}


type FB303Service interface {
    SimpleRPC(ctx context.Context, intParameter int32) (*ReservedKeyword, error)
}

type FB303ServiceChannelClientInterface interface {
    thrift.ClientInterface
    FB303Service
}

type FB303ServiceClientInterface interface {
    thrift.ClientInterface
    SimpleRPC(intParameter int32) (*ReservedKeyword, error)
}

type FB303ServiceContextClientInterface interface {
    FB303ServiceClientInterface
    SimpleRPCContext(ctx context.Context, intParameter int32) (*ReservedKeyword, error)
}

type FB303ServiceChannelClient struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ FB303ServiceChannelClientInterface = (*FB303ServiceChannelClient)(nil)

func NewFB303ServiceChannelClient(channel thrift.RequestChannel) *FB303ServiceChannelClient {
    return &FB303ServiceChannelClient{
        ch: channel,
    }
}

func (c *FB303ServiceChannelClient) Close() error {
    return c.ch.Close()
}

type FB303ServiceClient struct {
    chClient *FB303ServiceChannelClient
}
// Compile time interface enforcer
var _ FB303ServiceClientInterface = (*FB303ServiceClient)(nil)
var _ FB303ServiceContextClientInterface = (*FB303ServiceClient)(nil)

func NewFB303ServiceClient(prot thrift.Protocol) *FB303ServiceClient {
    return &FB303ServiceClient{
        chClient: NewFB303ServiceChannelClient(
            thrift.NewSerialChannel(prot),
        ),
    }
}

func (c *FB303ServiceClient) Close() error {
    return c.chClient.Close()
}

func (c *FB303ServiceChannelClient) SimpleRPC(ctx context.Context, intParameter int32) (*ReservedKeyword, error) {
    in := &reqFB303ServiceSimpleRPC{
        IntParameter: intParameter,
    }
    out := newRespFB303ServiceSimpleRPC()
    err := c.ch.Call(ctx, "simple_rpc", in, out)
    if err != nil {
        return nil, err
    }
    return out.GetSuccess(), nil
}

func (c *FB303ServiceClient) SimpleRPC(intParameter int32) (*ReservedKeyword, error) {
    return c.chClient.SimpleRPC(context.Background(), intParameter)
}

func (c *FB303ServiceClient) SimpleRPCContext(ctx context.Context, intParameter int32) (*ReservedKeyword, error) {
    return c.chClient.SimpleRPC(ctx, intParameter)
}


type FB303ServiceProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler            FB303Service
}

func NewFB303ServiceProcessor(handler FB303Service) *FB303ServiceProcessor {
    p := &FB303ServiceProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("simple_rpc", &procFuncFB303ServiceSimpleRPC{handler: handler})
    p.AddToFunctionServiceMap("simple_rpc", "FB303Service")

    return p
}

func (p *FB303ServiceProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *FB303ServiceProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *FB303ServiceProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *FB303ServiceProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *FB303ServiceProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *FB303ServiceProcessor) PackageName() string {
    return "module"
}

func (p *FB303ServiceProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.FB303Service")
}


type procFuncFB303ServiceSimpleRPC struct {
    handler FB303Service
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncFB303ServiceSimpleRPC)(nil)

func (p *procFuncFB303ServiceSimpleRPC) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqFB303ServiceSimpleRPC()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncFB303ServiceSimpleRPC) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("simple_rpc", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncFB303ServiceSimpleRPC) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqFB303ServiceSimpleRPC)
    result := newRespFB303ServiceSimpleRPC()
    retval, err := p.handler.SimpleRPC(ctx, args.IntParameter)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing SimpleRPC: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type MyService interface {
    Ping(ctx context.Context) (error)
    GetRandomData(ctx context.Context) (string, error)
    Sink(ctx context.Context, sink int64) (error)
    PutDataById(ctx context.Context, id int64, data string) (error)
    HasDataById(ctx context.Context, id int64) (bool, error)
    GetDataById(ctx context.Context, id int64) (string, error)
    DeleteDataById(ctx context.Context, id int64) (error)
    LobDataById(ctx context.Context, id int64, data string) (error)
    InvalidReturnForHack(ctx context.Context) ([]float32, error)
    RpcSkippedCodegen(ctx context.Context) (error)
}

type MyServiceChannelClientInterface interface {
    thrift.ClientInterface
    MyService
}

type MyServiceClientInterface interface {
    thrift.ClientInterface
    Ping() (error)
    GetRandomData() (string, error)
    Sink(sink int64) (error)
    PutDataById(id int64, data string) (error)
    HasDataById(id int64) (bool, error)
    GetDataById(id int64) (string, error)
    DeleteDataById(id int64) (error)
    LobDataById(id int64, data string) (error)
    InvalidReturnForHack() ([]float32, error)
    RpcSkippedCodegen() (error)
}

type MyServiceContextClientInterface interface {
    MyServiceClientInterface
    PingContext(ctx context.Context) (error)
    GetRandomDataContext(ctx context.Context) (string, error)
    SinkContext(ctx context.Context, sink int64) (error)
    PutDataByIdContext(ctx context.Context, id int64, data string) (error)
    HasDataByIdContext(ctx context.Context, id int64) (bool, error)
    GetDataByIdContext(ctx context.Context, id int64) (string, error)
    DeleteDataByIdContext(ctx context.Context, id int64) (error)
    LobDataByIdContext(ctx context.Context, id int64, data string) (error)
    InvalidReturnForHackContext(ctx context.Context) ([]float32, error)
    RpcSkippedCodegenContext(ctx context.Context) (error)
}

type MyServiceChannelClient struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ MyServiceChannelClientInterface = (*MyServiceChannelClient)(nil)

func NewMyServiceChannelClient(channel thrift.RequestChannel) *MyServiceChannelClient {
    return &MyServiceChannelClient{
        ch: channel,
    }
}

func (c *MyServiceChannelClient) Close() error {
    return c.ch.Close()
}

type MyServiceClient struct {
    chClient *MyServiceChannelClient
}
// Compile time interface enforcer
var _ MyServiceClientInterface = (*MyServiceClient)(nil)
var _ MyServiceContextClientInterface = (*MyServiceClient)(nil)

func NewMyServiceClient(prot thrift.Protocol) *MyServiceClient {
    return &MyServiceClient{
        chClient: NewMyServiceChannelClient(
            thrift.NewSerialChannel(prot),
        ),
    }
}

func (c *MyServiceClient) Close() error {
    return c.chClient.Close()
}

func (c *MyServiceChannelClient) Ping(ctx context.Context) (error) {
    in := &reqMyServicePing{
    }
    out := newRespMyServicePing()
    err := c.ch.Call(ctx, "ping", in, out)
    if err != nil {
        return err
    }
    return nil
}

func (c *MyServiceClient) Ping() (error) {
    return c.chClient.Ping(context.Background())
}

func (c *MyServiceClient) PingContext(ctx context.Context) (error) {
    return c.chClient.Ping(ctx)
}

func (c *MyServiceChannelClient) GetRandomData(ctx context.Context) (string, error) {
    in := &reqMyServiceGetRandomData{
    }
    out := newRespMyServiceGetRandomData()
    err := c.ch.Call(ctx, "getRandomData", in, out)
    if err != nil {
        return "", err
    }
    return out.GetSuccess(), nil
}

func (c *MyServiceClient) GetRandomData() (string, error) {
    return c.chClient.GetRandomData(context.Background())
}

func (c *MyServiceClient) GetRandomDataContext(ctx context.Context) (string, error) {
    return c.chClient.GetRandomData(ctx)
}

func (c *MyServiceChannelClient) Sink(ctx context.Context, sink int64) (error) {
    in := &reqMyServiceSink{
        Sink: sink,
    }
    out := newRespMyServiceSink()
    err := c.ch.Call(ctx, "sink", in, out)
    if err != nil {
        return err
    }
    return nil
}

func (c *MyServiceClient) Sink(sink int64) (error) {
    return c.chClient.Sink(context.Background(), sink)
}

func (c *MyServiceClient) SinkContext(ctx context.Context, sink int64) (error) {
    return c.chClient.Sink(ctx, sink)
}

func (c *MyServiceChannelClient) PutDataById(ctx context.Context, id int64, data string) (error) {
    in := &reqMyServicePutDataById{
        Id: id,
        Data: data,
    }
    out := newRespMyServicePutDataById()
    err := c.ch.Call(ctx, "putDataById", in, out)
    if err != nil {
        return err
    }
    return nil
}

func (c *MyServiceClient) PutDataById(id int64, data string) (error) {
    return c.chClient.PutDataById(context.Background(), id, data)
}

func (c *MyServiceClient) PutDataByIdContext(ctx context.Context, id int64, data string) (error) {
    return c.chClient.PutDataById(ctx, id, data)
}

func (c *MyServiceChannelClient) HasDataById(ctx context.Context, id int64) (bool, error) {
    in := &reqMyServiceHasDataById{
        Id: id,
    }
    out := newRespMyServiceHasDataById()
    err := c.ch.Call(ctx, "hasDataById", in, out)
    if err != nil {
        return false, err
    }
    return out.GetSuccess(), nil
}

func (c *MyServiceClient) HasDataById(id int64) (bool, error) {
    return c.chClient.HasDataById(context.Background(), id)
}

func (c *MyServiceClient) HasDataByIdContext(ctx context.Context, id int64) (bool, error) {
    return c.chClient.HasDataById(ctx, id)
}

func (c *MyServiceChannelClient) GetDataById(ctx context.Context, id int64) (string, error) {
    in := &reqMyServiceGetDataById{
        Id: id,
    }
    out := newRespMyServiceGetDataById()
    err := c.ch.Call(ctx, "getDataById", in, out)
    if err != nil {
        return "", err
    }
    return out.GetSuccess(), nil
}

func (c *MyServiceClient) GetDataById(id int64) (string, error) {
    return c.chClient.GetDataById(context.Background(), id)
}

func (c *MyServiceClient) GetDataByIdContext(ctx context.Context, id int64) (string, error) {
    return c.chClient.GetDataById(ctx, id)
}

func (c *MyServiceChannelClient) DeleteDataById(ctx context.Context, id int64) (error) {
    in := &reqMyServiceDeleteDataById{
        Id: id,
    }
    out := newRespMyServiceDeleteDataById()
    err := c.ch.Call(ctx, "deleteDataById", in, out)
    if err != nil {
        return err
    }
    return nil
}

func (c *MyServiceClient) DeleteDataById(id int64) (error) {
    return c.chClient.DeleteDataById(context.Background(), id)
}

func (c *MyServiceClient) DeleteDataByIdContext(ctx context.Context, id int64) (error) {
    return c.chClient.DeleteDataById(ctx, id)
}

func (c *MyServiceChannelClient) LobDataById(ctx context.Context, id int64, data string) (error) {
    in := &reqMyServiceLobDataById{
        Id: id,
        Data: data,
    }
    return c.ch.Oneway(ctx, "lobDataById", in)
}

func (c *MyServiceClient) LobDataById(id int64, data string) (error) {
    return c.chClient.LobDataById(context.Background(), id, data)
}

func (c *MyServiceClient) LobDataByIdContext(ctx context.Context, id int64, data string) (error) {
    return c.chClient.LobDataById(ctx, id, data)
}

func (c *MyServiceChannelClient) InvalidReturnForHack(ctx context.Context) ([]float32, error) {
    in := &reqMyServiceInvalidReturnForHack{
    }
    out := newRespMyServiceInvalidReturnForHack()
    err := c.ch.Call(ctx, "invalid_return_for_hack", in, out)
    if err != nil {
        return nil, err
    }
    return out.GetSuccess(), nil
}

func (c *MyServiceClient) InvalidReturnForHack() ([]float32, error) {
    return c.chClient.InvalidReturnForHack(context.Background())
}

func (c *MyServiceClient) InvalidReturnForHackContext(ctx context.Context) ([]float32, error) {
    return c.chClient.InvalidReturnForHack(ctx)
}

func (c *MyServiceChannelClient) RpcSkippedCodegen(ctx context.Context) (error) {
    in := &reqMyServiceRpcSkippedCodegen{
    }
    out := newRespMyServiceRpcSkippedCodegen()
    err := c.ch.Call(ctx, "rpc_skipped_codegen", in, out)
    if err != nil {
        return err
    }
    return nil
}

func (c *MyServiceClient) RpcSkippedCodegen() (error) {
    return c.chClient.RpcSkippedCodegen(context.Background())
}

func (c *MyServiceClient) RpcSkippedCodegenContext(ctx context.Context) (error) {
    return c.chClient.RpcSkippedCodegen(ctx)
}


type MyServiceProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler            MyService
}

func NewMyServiceProcessor(handler MyService) *MyServiceProcessor {
    p := &MyServiceProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("ping", &procFuncMyServicePing{handler: handler})
    p.AddToProcessorFunctionMap("getRandomData", &procFuncMyServiceGetRandomData{handler: handler})
    p.AddToProcessorFunctionMap("sink", &procFuncMyServiceSink{handler: handler})
    p.AddToProcessorFunctionMap("putDataById", &procFuncMyServicePutDataById{handler: handler})
    p.AddToProcessorFunctionMap("hasDataById", &procFuncMyServiceHasDataById{handler: handler})
    p.AddToProcessorFunctionMap("getDataById", &procFuncMyServiceGetDataById{handler: handler})
    p.AddToProcessorFunctionMap("deleteDataById", &procFuncMyServiceDeleteDataById{handler: handler})
    p.AddToProcessorFunctionMap("lobDataById", &procFuncMyServiceLobDataById{handler: handler})
    p.AddToProcessorFunctionMap("invalid_return_for_hack", &procFuncMyServiceInvalidReturnForHack{handler: handler})
    p.AddToProcessorFunctionMap("rpc_skipped_codegen", &procFuncMyServiceRpcSkippedCodegen{handler: handler})
    p.AddToFunctionServiceMap("ping", "MyService")
    p.AddToFunctionServiceMap("getRandomData", "MyService")
    p.AddToFunctionServiceMap("sink", "MyService")
    p.AddToFunctionServiceMap("putDataById", "MyService")
    p.AddToFunctionServiceMap("hasDataById", "MyService")
    p.AddToFunctionServiceMap("getDataById", "MyService")
    p.AddToFunctionServiceMap("deleteDataById", "MyService")
    p.AddToFunctionServiceMap("lobDataById", "MyService")
    p.AddToFunctionServiceMap("invalid_return_for_hack", "MyService")
    p.AddToFunctionServiceMap("rpc_skipped_codegen", "MyService")

    return p
}

func (p *MyServiceProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *MyServiceProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *MyServiceProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *MyServiceProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *MyServiceProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *MyServiceProcessor) PackageName() string {
    return "module"
}

func (p *MyServiceProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.MyService")
}


type procFuncMyServicePing struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServicePing)(nil)

func (p *procFuncMyServicePing) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServicePing()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServicePing) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("ping", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServicePing) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespMyServicePing()
    err := p.handler.Ping(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing Ping: " + err.Error(), err)
        return x, x
    }

    return result, nil
}


type procFuncMyServiceGetRandomData struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServiceGetRandomData)(nil)

func (p *procFuncMyServiceGetRandomData) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServiceGetRandomData()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServiceGetRandomData) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getRandomData", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServiceGetRandomData) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespMyServiceGetRandomData()
    retval, err := p.handler.GetRandomData(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetRandomData: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncMyServiceSink struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServiceSink)(nil)

func (p *procFuncMyServiceSink) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServiceSink()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServiceSink) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("sink", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServiceSink) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqMyServiceSink)
    result := newRespMyServiceSink()
    err := p.handler.Sink(ctx, args.Sink)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing Sink: " + err.Error(), err)
        return x, x
    }

    return result, nil
}


type procFuncMyServicePutDataById struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServicePutDataById)(nil)

func (p *procFuncMyServicePutDataById) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServicePutDataById()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServicePutDataById) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("putDataById", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServicePutDataById) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqMyServicePutDataById)
    result := newRespMyServicePutDataById()
    err := p.handler.PutDataById(ctx, args.Id, args.Data)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing PutDataById: " + err.Error(), err)
        return x, x
    }

    return result, nil
}


type procFuncMyServiceHasDataById struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServiceHasDataById)(nil)

func (p *procFuncMyServiceHasDataById) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServiceHasDataById()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServiceHasDataById) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("hasDataById", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServiceHasDataById) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqMyServiceHasDataById)
    result := newRespMyServiceHasDataById()
    retval, err := p.handler.HasDataById(ctx, args.Id)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing HasDataById: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncMyServiceGetDataById struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServiceGetDataById)(nil)

func (p *procFuncMyServiceGetDataById) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServiceGetDataById()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServiceGetDataById) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getDataById", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServiceGetDataById) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqMyServiceGetDataById)
    result := newRespMyServiceGetDataById()
    retval, err := p.handler.GetDataById(ctx, args.Id)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetDataById: " + err.Error(), err)
        return x, x
    }

    result.Success = &retval
    return result, nil
}


type procFuncMyServiceDeleteDataById struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServiceDeleteDataById)(nil)

func (p *procFuncMyServiceDeleteDataById) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServiceDeleteDataById()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServiceDeleteDataById) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("deleteDataById", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServiceDeleteDataById) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqMyServiceDeleteDataById)
    result := newRespMyServiceDeleteDataById()
    err := p.handler.DeleteDataById(ctx, args.Id)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing DeleteDataById: " + err.Error(), err)
        return x, x
    }

    return result, nil
}


type procFuncMyServiceLobDataById struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServiceLobDataById)(nil)

func (p *procFuncMyServiceLobDataById) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServiceLobDataById()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServiceLobDataById) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("lobDataById", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServiceLobDataById) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqMyServiceLobDataById)
    err := p.handler.LobDataById(ctx, args.Id, args.Data)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing LobDataById: " + err.Error(), err)
        return x, x
    }

    return nil, nil
}


type procFuncMyServiceInvalidReturnForHack struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServiceInvalidReturnForHack)(nil)

func (p *procFuncMyServiceInvalidReturnForHack) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServiceInvalidReturnForHack()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServiceInvalidReturnForHack) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("invalid_return_for_hack", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServiceInvalidReturnForHack) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespMyServiceInvalidReturnForHack()
    retval, err := p.handler.InvalidReturnForHack(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing InvalidReturnForHack: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncMyServiceRpcSkippedCodegen struct {
    handler MyService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncMyServiceRpcSkippedCodegen)(nil)

func (p *procFuncMyServiceRpcSkippedCodegen) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqMyServiceRpcSkippedCodegen()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncMyServiceRpcSkippedCodegen) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("rpc_skipped_codegen", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncMyServiceRpcSkippedCodegen) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    result := newRespMyServiceRpcSkippedCodegen()
    err := p.handler.RpcSkippedCodegen(ctx)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing RpcSkippedCodegen: " + err.Error(), err)
        return x, x
    }

    return result, nil
}


type DbMixedStackArguments interface {
    GetDataByKey0(ctx context.Context, key string) ([]byte, error)
    GetDataByKey1(ctx context.Context, key string) ([]byte, error)
}

type DbMixedStackArgumentsChannelClientInterface interface {
    thrift.ClientInterface
    DbMixedStackArguments
}

type DbMixedStackArgumentsClientInterface interface {
    thrift.ClientInterface
    GetDataByKey0(key string) ([]byte, error)
    GetDataByKey1(key string) ([]byte, error)
}

type DbMixedStackArgumentsContextClientInterface interface {
    DbMixedStackArgumentsClientInterface
    GetDataByKey0Context(ctx context.Context, key string) ([]byte, error)
    GetDataByKey1Context(ctx context.Context, key string) ([]byte, error)
}

type DbMixedStackArgumentsChannelClient struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ DbMixedStackArgumentsChannelClientInterface = (*DbMixedStackArgumentsChannelClient)(nil)

func NewDbMixedStackArgumentsChannelClient(channel thrift.RequestChannel) *DbMixedStackArgumentsChannelClient {
    return &DbMixedStackArgumentsChannelClient{
        ch: channel,
    }
}

func (c *DbMixedStackArgumentsChannelClient) Close() error {
    return c.ch.Close()
}

type DbMixedStackArgumentsClient struct {
    chClient *DbMixedStackArgumentsChannelClient
}
// Compile time interface enforcer
var _ DbMixedStackArgumentsClientInterface = (*DbMixedStackArgumentsClient)(nil)
var _ DbMixedStackArgumentsContextClientInterface = (*DbMixedStackArgumentsClient)(nil)

func NewDbMixedStackArgumentsClient(prot thrift.Protocol) *DbMixedStackArgumentsClient {
    return &DbMixedStackArgumentsClient{
        chClient: NewDbMixedStackArgumentsChannelClient(
            thrift.NewSerialChannel(prot),
        ),
    }
}

func (c *DbMixedStackArgumentsClient) Close() error {
    return c.chClient.Close()
}

func (c *DbMixedStackArgumentsChannelClient) GetDataByKey0(ctx context.Context, key string) ([]byte, error) {
    in := &reqDbMixedStackArgumentsGetDataByKey0{
        Key: key,
    }
    out := newRespDbMixedStackArgumentsGetDataByKey0()
    err := c.ch.Call(ctx, "getDataByKey0", in, out)
    if err != nil {
        return nil, err
    }
    return out.GetSuccess(), nil
}

func (c *DbMixedStackArgumentsClient) GetDataByKey0(key string) ([]byte, error) {
    return c.chClient.GetDataByKey0(context.Background(), key)
}

func (c *DbMixedStackArgumentsClient) GetDataByKey0Context(ctx context.Context, key string) ([]byte, error) {
    return c.chClient.GetDataByKey0(ctx, key)
}

func (c *DbMixedStackArgumentsChannelClient) GetDataByKey1(ctx context.Context, key string) ([]byte, error) {
    in := &reqDbMixedStackArgumentsGetDataByKey1{
        Key: key,
    }
    out := newRespDbMixedStackArgumentsGetDataByKey1()
    err := c.ch.Call(ctx, "getDataByKey1", in, out)
    if err != nil {
        return nil, err
    }
    return out.GetSuccess(), nil
}

func (c *DbMixedStackArgumentsClient) GetDataByKey1(key string) ([]byte, error) {
    return c.chClient.GetDataByKey1(context.Background(), key)
}

func (c *DbMixedStackArgumentsClient) GetDataByKey1Context(ctx context.Context, key string) ([]byte, error) {
    return c.chClient.GetDataByKey1(ctx, key)
}


type DbMixedStackArgumentsProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler            DbMixedStackArguments
}

func NewDbMixedStackArgumentsProcessor(handler DbMixedStackArguments) *DbMixedStackArgumentsProcessor {
    p := &DbMixedStackArgumentsProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("getDataByKey0", &procFuncDbMixedStackArgumentsGetDataByKey0{handler: handler})
    p.AddToProcessorFunctionMap("getDataByKey1", &procFuncDbMixedStackArgumentsGetDataByKey1{handler: handler})
    p.AddToFunctionServiceMap("getDataByKey0", "DbMixedStackArguments")
    p.AddToFunctionServiceMap("getDataByKey1", "DbMixedStackArguments")

    return p
}

func (p *DbMixedStackArgumentsProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *DbMixedStackArgumentsProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *DbMixedStackArgumentsProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *DbMixedStackArgumentsProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *DbMixedStackArgumentsProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *DbMixedStackArgumentsProcessor) PackageName() string {
    return "module"
}

func (p *DbMixedStackArgumentsProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.DbMixedStackArguments")
}


type procFuncDbMixedStackArgumentsGetDataByKey0 struct {
    handler DbMixedStackArguments
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncDbMixedStackArgumentsGetDataByKey0)(nil)

func (p *procFuncDbMixedStackArgumentsGetDataByKey0) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqDbMixedStackArgumentsGetDataByKey0()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncDbMixedStackArgumentsGetDataByKey0) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getDataByKey0", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncDbMixedStackArgumentsGetDataByKey0) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqDbMixedStackArgumentsGetDataByKey0)
    result := newRespDbMixedStackArgumentsGetDataByKey0()
    retval, err := p.handler.GetDataByKey0(ctx, args.Key)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetDataByKey0: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


type procFuncDbMixedStackArgumentsGetDataByKey1 struct {
    handler DbMixedStackArguments
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncDbMixedStackArgumentsGetDataByKey1)(nil)

func (p *procFuncDbMixedStackArgumentsGetDataByKey1) Read(iprot thrift.Decoder) (thrift.Struct, thrift.Exception) {
    args := newReqDbMixedStackArgumentsGetDataByKey1()
    if err := args.Read(iprot); err != nil {
        return nil, err
    }
    iprot.ReadMessageEnd()
    return args, nil
}

func (p *procFuncDbMixedStackArgumentsGetDataByKey1) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Encoder) (err thrift.Exception) {
    var err2 error
    messageType := thrift.REPLY
    switch result.(type) {
    case thrift.ApplicationException:
        messageType = thrift.EXCEPTION
    }

    if err2 = oprot.WriteMessageBegin("getDataByKey1", messageType, seqId); err2 != nil {
        err = err2
    }
    if err2 = result.Write(oprot); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
        err = err2
    }
    if err2 = oprot.Flush(); err == nil && err2 != nil {
        err = err2
    }
    return err
}

func (p *procFuncDbMixedStackArgumentsGetDataByKey1) RunContext(ctx context.Context, reqStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
    args := reqStruct.(*reqDbMixedStackArgumentsGetDataByKey1)
    result := newRespDbMixedStackArgumentsGetDataByKey1()
    retval, err := p.handler.GetDataByKey1(ctx, args.Key)
    if err != nil {
        x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing GetDataByKey1: " + err.Error(), err)
        return x, x
    }

    result.Success = retval
    return result, nil
}


