#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/includes/src/matching_struct_names.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import thrift.py3.types
import importlib
from collections.abc import Mapping, Sequence, Set

"""
    This is a helper module to define py3 container types.
    All types defined here are re-exported in the parent `.types` module.
    Only `import` types defined here via the parent `.types` module.
    If you `import` them directly from here, you will get nasty import errors.
"""

_fbthrift__module_name__ = "matching_struct_names.types"

import matching_struct_names.types as _matching_struct_names_types
import module.types as _module_types

def get_types_reflection():
    return importlib.import_module(
        "matching_struct_names.types_reflection"
    )

__all__ = []

class List__MyStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__MyStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__MyStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, _matching_struct_names_types.MyStruct)
        ):
            raise TypeError(f"{item!r} is not of type _matching_struct_names_types.MyStruct")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _matching_struct_names_types.MyStruct):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__MyStruct()


Sequence.register(List__MyStruct)

__all__.append('List__MyStruct')


class List__List__MyStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__MyStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__MyStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[_matching_struct_names_types.MyStruct]")
        if not isinstance(item, _matching_struct_names_types.List__MyStruct):
            item = _matching_struct_names_types.List__MyStruct(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _matching_struct_names_types.List__MyStruct):
            return item
        try:
            return _matching_struct_names_types.List__MyStruct(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__MyStruct()


Sequence.register(List__List__MyStruct)

__all__.append('List__List__MyStruct')


class List__module_MyStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__module_MyStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__module_MyStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__module_MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, _module_types.MyStruct)
        ):
            raise TypeError(f"{item!r} is not of type _module_types.MyStruct")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.MyStruct):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__module_MyStruct()


Sequence.register(List__module_MyStruct)

__all__.append('List__module_MyStruct')


class List__List__module_MyStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__module_MyStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__module_MyStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__module_MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[_module_types.MyStruct]")
        if not isinstance(item, _matching_struct_names_types.List__module_MyStruct):
            item = _matching_struct_names_types.List__module_MyStruct(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _matching_struct_names_types.List__module_MyStruct):
            return item
        try:
            return _matching_struct_names_types.List__module_MyStruct(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__module_MyStruct()


Sequence.register(List__List__module_MyStruct)

__all__.append('List__List__module_MyStruct')


